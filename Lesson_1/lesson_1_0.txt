1. Язык Си (С++) является компилируемыми языком программирования. Т.е. для получения исполняемого (в данной ОС) файла (binary EXEcutable) 
из исходного текстового файла (.cpp), написанного в соответствии с синтаксисом языка Си (С++), необходима специальная программа - 
компилятор - которая анализирует текст и генерирует исполняемый файл. MinGW это набор программ, среди которых есть программе g++ - компилятор
языка Си (С++). Скачать MinGW: https://sourceforge.net/projects/mingw/files/

Распаковываете архив и открываете консоль Windows с помощью комбинации клавишь Win + R и вводите в поле cmd. В консоли можно перемещаться
в нужную директорию с помощью команды cd, например:

cd C:\CppCourse\Lesson_1

переходите в директорию, куда был распакован архив, и запускайте установщик. В открывшемся окне помечайте все пункты правой клавишей мыши + Mark for Installation,
затем в верхнем левом углу нажимаете на кнопку меню и Apply Changes -> Apply. После окончания скачивания, открывайте свойства ОС:

правой кнопкой мыши на "Мой (этот) компьютер" -> Свойства -> Дополнительные параметры системы -> Переменные окружения (среды).
в списке ниже находите строку с названием Path, нажимаете на нее 2-й щелчком, в открывшемся окне:

a) Windows 10: нажимаете "Создать" и добавляете путь к установленному MinGW, обычно это C:\MinGW\bin
b) прочие Windows: в конце уже имеющейся строки Path добавляете ;C:\MinGW\bin

все закрываете нажатием ОК. Консоль cmd следует перезапустить. После этого введите команду:

g++

она должна быть уже определена в Системе, но выдавать fatal error: no input files

Установите также блокнот с подсветкой синтаксиса Notepad++.   https://notepad-plus-plus.org/

-----------------------------------------------------------------------------------------------------------------------------------------------------
2. Переменные в языке Си служат для хранения данных и написания выражений с ними, которые и образуют программу.

Объявление переменной (variable declaration):

T x;

Определение переменной (variable definition):

T x = value;

Здесь Т - любой из типов переменной в языке Си (int, float, double, char, bool, long long); x - название переменной, value - значение, допустимое для типа Т.

int, char, bool, long long - это целочисленные типы; float, double - тип для действительных чисел (конечной точности).

Всякий раз, когда программа во время выполнения встречает объявление (определение) переменной, в оперативной памяти выделяется ячейка размером Z байт.
Каждый байт составляет 8 бит, каждый бит может хранить значение 0 или 1. Таким образом, значение value представляется в 2-ичном виде и сохраняется в
выделенную ячейку памяти. Название переменной (x) позволяет в дальнейшем обращаться (ссылаться) на этот блок памяти м использвоать значение в нем.

Обявление или определение переменной x может встречаться в программе только 1 раз в пределах одного блока. Под блоком понимается пара фигурных скобок { }.

Значение Z для типов:

char, bool - 1 байт
int, float - 4 байт
long long, double - 8 байт

слово short или long можно приписать слева от типа Т при объявлении (определении) переменной, что приведет к тому, что для переменной в памяти будет выделено
в 2 раза меньше или больше байт:

short int x;  - занимает 2 байта
long int x; - занимает 4 байта, так как не работает. Работает только тип long long

-------------------------------------------------------------------------------
Пример:

int x = 5;

число 5 в двоичном представлении имеет вид: 101  (старший бит слева, младший - справа)

Определение переменной x означает выделение ячейки памяти разменром 4 байт (32 бит) и запись числа 5 в двоичном представлении в эту ячейку:

[00000000][00000000][00000000][00000101]

Самый старший бит (самый крайний левый) называется "знаковым" и отвечает за знак числа. Если бит хранит 0, то число положительное, если 1 - отрицательное:

int y = -5;

[10000000][00000000][00000000][00000101]

Все остальные биты служат для хранения двоичного представления числа. Если все такие биты хранят 1, то переменная достигает максимального значения,
которое может иметь переменная данного типа Т. Например, для int таким максимальным значением является: 2,147,483,647

Подробнее:  https://ru.wikipedia.org/wiki/Limits.h

Существует ключевое слово unsigned, которое можно приписать слева от типа Т при объявлении (определении) переменной, что сделает число беззнаковым - т.е.
старший (знаковый) бит будет служить для представления числа, вместе с остальными. Максимальным беззнаковым целым числом является:

unsigned int x = 4294967295;

Попытка записать в переменную значение, которое выходит за границу допустимого представления числа в двоичной форме, называется "переполнением типа":

int x = 3000000000;

Это выражение будет скомпилировано, но при последующем обращении к переменной x будет получено совсем другое значение, а не ожидаемое 300000000.

-----------------------------------------------------------------------------------------------------------------------------------------------------
3. Любая программа на языке Си начинается с функции main(), которая является точкой входа в программу. Функция main() должна всегда писаться только таким образом:

int main(int argc, char** argv) {


  return 0;
}

функция main() открывает самый первый блок { } в программе, содержимое которого и будет являться набором действий, выполняемых программой.
Последней строкой в блоке main должно быть выражение:

return 0;

-----------------------------------------------------------------------------------------------------------------------------------------------------
4. Чтобы вывести на экран консоли какой-то текст, нужно использовать:

а) в языке Си - функцию printf()
b) в языке С++ - объект std::cout

а) Функция printf() должна вызываться с 1-м или более аргументами, перечисленными в круглых скобках ( ) через запятую. Первым аргументом всегда
является строка, заключенная в двойные кавычки. Эта строка и будет напечатана. Например:

printf("Hello, World\n");  - напечатает строку Hello, World с сделает перенос курсора на следующую строку.

Аргумент-строка функции printf() может содержать placeholder-ы - такие места, куда будут подставлены значения остальных аргументов, например:

int main(int argc, char** argv) {
  int x = 5;
  float y = 3.14;

  printf("x = %i, y = %f\n", x, y);

  return 0;
}

В этой программе определены переменные x и y, а затем выводится строка: x = 5, y = 3.14

Каждому типу T соответствует определенный формат placeholder'а, например:

char - %c
short - %h
bool, int - %i, %d
long long - %lli
float - %f
double - %lf

Чтобы компилятор понял, что означает выражение printf(), эту функцию необходимо объявить. Ее объявление содержится в заголовочном файте cstdio (или stdio.h), который
необходимо подключить к программе с помощью директивы:

#include <cstdio>

Директивы #include должны располагаться в самом верху текстового файла, до определения функции main().

b) объект std::cout определен в заголовочном файле iostream, для его использования файл нужно подключить:

#include <iostream>

Та же самая программ, но с применением std::cout:

#include <iostream>

int main(int argc, char** argv) {
  int x = 5;
  float y = 3.14;

  std::cout << "x = " << x << ", y = " << y << "\n";

  return 0;
}

Обратим внимание, что placeholder'ы здесь не встречаются. С помощью оператора потокового вывода << в объект std::cout последовательно подаются строки (в кавычках) и значения.
Образуется итоговая строка:

x = 5, y = 3.14

-----------------------------------------------------------------------------------------------------------------------------------------------------
5. Над переменными типа Т определены стандартные операции:

а) Арифметические:  унарные +, -  бинарные  +, -, *, /, % (остаток от деления целых чисел)   - результатом таких операторов является значение типа Т

  int a = 5;
  int b = 10;
  int c = a - b;   // c равно -5

  int x = 12;
  int y = -x;  // y равно -12

б) Логические:  <, >, <=, >=, ==, != (не равно)  - результатом таких операторов является значение типа bool

  int x = 12;
  bool res = x < 5;  // res равно false

  int y = 15;
  bool out = x / y == 0;  // out равен true

в) Присваивание:  =, +=, -=, *=, /=, %= (только для целого типа Т)

  int a = 5;
  int b = 12;

  b += a;  // b будет равно 17
  b = b + a;  // это "развернутая" запись оператор +=

г) Инкремент, декремент:  ++, --

  int a = 5;
  int b = 11;

  ++a;  // префиксный, а будет равно 6
  a++;  // постфиксный, а будет равно 7

  ++b;
  b += b + 1;  // это "развернутая" запись инкремента (любого)

-------------------------------------------------
Операторы имеют приоритет в соответствии с таблицей:  http://ru.cppreference.com/w/cpp/language/operator_precedence

Пример:

int a = 11;
int b = 4;
int c = ++a + b++;  // сначала выполнится b++, затем ++a, затем a + b, затем присваивание =. Значение c == 17;

Почти все операторы, имеющие одинаковый приоритет, выполняются слева-направо в порядке своего следования в выражении:

int a = 5*2 - 15/3 + 6%2;  // порядок выполнения: 5*2, 15/3, 6%2, -, +, =   Получится a == 5

Операторы присваивания =, +=, -=, *=, /=, %= имеют одинаковый приоритет, но выполняются справа-налево в выражении:
Присваивание по цепочке:

int a = 12;
int b = 5;
int c = 3;
c += a -= b;  // сначала выполнится: a -= b, а будет равно 7, результатом оператора присваивания является 
новое значение слева от оператора, т.е. 7. Затем выполнится c += a, где а == 7, получится c == 10.

Скобки изменяют приоритет:

int a = (5*(2 - 15/3) + 6)%2;  // порядок выполнения: 15/3, 2 - 5, 5*-3, -15 + 6, -9%2   Получится a == 1 

-----------------------------------------------------------------------------------------------------------------------------------------------------
6. Инструкция if:

if (expression) {

}

под expression понимается любое выражение, которое преобразуется к типу bool. Переменная типа bool - это переменная целого типа размером 1 байт,
но любое ненулевое (положительное, отрицательное) значение интерпретируется как true, а нуль - как false.

Если expression равно true, блок if выполняется 1 раз, в противном случае не выполняется.

Инструкцию можно продолжить:

if (expression) {

} else {

}

Блок else выполнится, если expression равно false

if (expression_1) {

} else if (expression_2) {

} else if (expression_3) {

...

} else {

}

1-й блок выполнится, если expression_1 равно true, после чего инструкция if полностью закончится. Если expression_1 равно false, то будет произведена
проверка expression_2, и если оно равно true, выполнится 2-й блок, после чего вся инструкция if закончится. Если все expression_N равны false, то выполнится
последний блок else.

Пример программы для решения квадратного уравнения:

#include <cstdio>
#include <cmath>  // для функции sqrt()

int main(int argc, char** argv) {

  double a = 3.14;
  double b = 2.71;
  double c = 0.05;

  double D = b*b - 4*a*c;

  if (D > 0) {
    double x = (-b + sqrt(D)) / 2 / a;
    double y = (-b - sqrt(D)) / 2 / a;
    printf("x = %lf, y = %lf\n", x, y);
  } else if (D == 0) {
    double x = -b / 2 / a;
    printf("x = %lf\n");
  } else {
    printf("No roots\n");
  }

  return 0;
}

Обратим внимание, что хотя в программе два раза встречается определение переменной x, эти определения находятся в различных блоках { }, и не порождают
ошибок компиляции.

-----------------------------------------------------------------------------------------------------------------------------------------------------
7. Цикл while:

while (expression) {

}

Если expression равно true, то блок while выполняется 1 раз, в противном случае не выполняется. В конце вполнения блока while делается новая проверка
expression и если оно равно true, цикл повторяется (итерация), или выходит в случае false.

Рассмотрим программу вычисления скалярного произведения двух векторов. Вектора будут иметь длину 5 и целочисленные значения координат. Для хранения векторов
вводится новый тип данных - массив:

Объявление массива:  T x[];
Определение массива: T x[] = {value_1, value_2, ..., value_3};

Программа:

#include <cstdio>

int main(int argc, char** argv) {

  int i = 0;
  int X[] = {1, 2, 3, 4, 5};
  int Y[] = {6, 7, 8, 9, 10};
  int scalar = 0;

  while (i < 5) {
    scalar += X[i] * Y[i];
    ++i;
  }

  printf("scalar = %i\n", scalar);
  return 0;
}

-----------------------------------------------------------------------------------------------------------------------------------------------------
8. Цикл for:

for (init ; expression ; increment) {

}

Цикл for выполняется в соответствии со схемой:

1. выполняется выражение init
2. вычисляется выражение expression, которое приводится к типу bool. Если false - выход из цикла for, если true - см. п. 3
3. выполняется блок for (то, что в фигурных скобках { } )
4. выполняется выражение increment
5. вычисляется выражение expression, которое приводится к типу bool. Если false - выход из цикла for, если true - см. п. 3

Вычисление скалярного произведения:

#include <iostream>

int main(int argc, char** argv) {

  int X[] = {1, 2, 3, 4, 5};
  int Y[] = {6, 7, 8, 9, 10};
  int scalar = 0;

  for (int i = 0; i < 5; ++i) {
    scalar += X[i] * Y[i];
  }

  std::cout << "scalar = " << scalar << "\n";
  return 0;
}

-----------------------------------------------------------------------------------------------------------------------------------------------------
9. компиляция программы:

g++ program_name.cpp -o executable_name

запуск:

executable_name


